#!/usr/bin/env node

import {McpServer} from '@modelcontextprotocol/sdk/server/mcp.js';
import {StdioServerTransport} from '@modelcontextprotocol/sdk/server/stdio.js';
import {SSEServerTransport} from "@modelcontextprotocol/sdk/server/sse.js";
import express, {Request, Response} from "express";
import {z} from 'zod';
import fetch from 'node-fetch';
import {GeneratePresentationResponse} from "./schemas.js";
import {Command, Option} from 'commander';

const CAPPT_BASE_URL = 'https://openapi.cappt.cc';

const CAPPT_TOOLS = {
    GENERATE_OUTLINE: 'generate_outline',
    GENERATE_PRESENTATION: 'generate_presentation'
};

const GENERATE_OUTLINE_PROMPT_TEMPLATE = `## 角色
你是一名PPT大纲生成专家，擅长根据主题生成逻辑清晰、内容丰富的PPT提纲。
## 任务
根据用户输入的主题信息，生成符合以下规则的PPT大纲，语言需与主题一致，仅输出符合格式要求的大纲内容。
## 规则
1. 语言一致：大纲语言必须与输入主题的语言一致。
2. 标题层级：包含1-4级标题：
   - 1级标题：标题及副标题
   - 2级标题：3-5个子主题方向，每个附带一句话副标题
   - 3级标题：每个子主题方向下随机生成3-5个细分领域，每个附带一句话副标题
   - 4级标题：每个细分领域下生成3-8个小章节，附带10-30字的具体内容
3. 数量要求：
   - 每个子主题方向下的细分领域数量不低于3个
   - 每个细分领域下的小章节数量不低于3个
4. 随机性：禁止所有子主题方向和细分领域的标题数量完全相同。
5. 格式：用Markdown格式输出。
## 格式
\`\`\`markdown
# [标题]
> [副标题]
## 1. [子主题方向]
> [子主题方向的副标题]
### 1.1 [细分领域]
> [细分领域的副标题]
#### 1.1.1 [小章节]
> [小章节具体内容]
\`\`\`
## 输出格式
\`\`\`
# 主题
> 副标题
## 1. 子主题方向
> 子主题方向的副标题
### 1.1 细分领域
> 细分领域的副标题
#### 1.1.1 小章节
> 小章节具体内容
\`\`\`

## 用户输入如下：
'''
{input}
'''

## 约束
生成标准大纲之后，必须调用\`${CAPPT_TOOLS.GENERATE_PRESENTATION}\`工具生成PPT

## 输出格式
\`\`\`
您的PPT已经生成，共计{totalPage}页，

查看获取源文件请点击链接：
[PPT下载]({editorUrl})

PPT封面预览：
![封面图]({thumbnail})
\`\`\`
`;

function serve(cappt_url: string, cappt_token: string): McpServer {
    const server = new McpServer(
        {
            name: 'Cappt',
            version: '0.0.1',
        },
        {
            instructions: `Use \`${CAPPT_TOOLS.GENERATE_OUTLINE}\` to generate a standard outline, then use \`${CAPPT_TOOLS.GENERATE_PRESENTATION}\` to create the presentation`,
            capabilities: {
                tools: {},
                logging: {},
            }
        }
    );

    server.prompt(
        CAPPT_TOOLS.GENERATE_OUTLINE,
        'Generate a standard outline based on user input.',
        {
            input: z.string().describe('User input, eg: title, article, etc.')
        },
        ({input}) => ({
            messages: [{
                role: 'user',
                content: {
                    type: 'text',
                    text: GENERATE_OUTLINE_PROMPT_TEMPLATE.replace('{input}', input)
                }
            }]
        })
    );

    server.tool(
        CAPPT_TOOLS.GENERATE_PRESENTATION,
        `Generate presentation based on the outline generated by \`${CAPPT_TOOLS.GENERATE_OUTLINE}\``,
        {
            outline: z.string().describe(`A standard outline generated by \`${CAPPT_TOOLS.GENERATE_OUTLINE}\``),
            include_gallery: z.boolean().optional().describe('Include gallery in the generation result')
        },
        async ({outline, include_gallery}) => {
            const response = await fetch(`${cappt_url}/ppt`, {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${cappt_token}`,
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({'outline': outline, 'includeGallery': include_gallery}),
            });
            const result = await response.json();
            const data = GeneratePresentationResponse.parse(result);
            const code = data.code;
            const body = data.data;
            const text = code != 200
                ? `Failed to generate presentation: ${JSON.stringify(data)}`
                : JSON.stringify(body);
            return {
                content: [{type: 'text', text: text}]
            };
        }
    )

    return server;
}

async function main() {
    const program = new Command();
    program.addOption(new Option('--cappt-url <url>', 'Cappt API base URL').env('CAPPT_URL').default(CAPPT_BASE_URL))
        .addOption(new Option('--cappt-token <token>', 'Cappt API token').env('CAPPT_TOKEN').makeOptionMandatory())
        .addOption(new Option('--transport <method>', 'Transport method').choices(['stdio', 'sse']).env('TRANSPORT').default('stdio'))
        .addOption(new Option('--sse-host <host>', 'SSE server host').env('SSE_HOST').default('0.0.0.0'))
        .addOption(new Option('--sse-port <port>', 'SSE server port').env('SSE_PORT').default(8000));
    program.parse(process.argv);
    const options = program.opts();
    const server = serve(options.capptUrl, options.capptToken);
    if (options.transport === 'stdio') {
        const transport = new StdioServerTransport();
        await server.connect(transport);
    } else if (options.transport === 'sse') {
        const app = express();
        const transports: { [sessionId: string]: SSEServerTransport } = {};
        app.get("/sse", async (_: Request, res: Response) => {
            const transport = new SSEServerTransport('/messages', res);
            transports[transport.sessionId] = transport;
            res.on("close", () => {
                delete transports[transport.sessionId];
            });
            await server.connect(transport);
        });
        app.post("/messages", async (req: Request, res: Response) => {
            const sessionId = req.query.sessionId as string;
            const transport = transports[sessionId];
            if (transport) {
                await transport.handlePostMessage(req, res);
            } else {
                res.status(400).send('No transport found for sessionId');
            }
        });
        app.listen(options.ssePort, options.sseHost);
    } else {
        throw new Error(`Unsupported transport method: ${options.transport}`);
    }
}

main().catch((error) => {
    console.error("Fatal error in main():", error);
    process.exit(1);
});
