#!/usr/bin/env node

import {McpServer} from '@modelcontextprotocol/sdk/server/mcp.js';
import {Transport} from '@modelcontextprotocol/sdk/shared/transport.js';
import {StdioServerTransport} from '@modelcontextprotocol/sdk/server/stdio.js';
import {SSEServerTransport} from "@modelcontextprotocol/sdk/server/sse.js";
import {StreamableHTTPServerTransport} from '@modelcontextprotocol/sdk/server/streamableHttp.js';
import express, {Request, Response} from 'express';
import {z} from 'zod';
import fetch from 'node-fetch';
import {GeneratePresentationResponse} from './schemas.js';
import {Command, Option} from 'commander';
import {ErrorCode, isInitializeRequest, JSONRPCError} from "@modelcontextprotocol/sdk/types.js"
import {randomUUID} from "node:crypto";

const CapptBaseUrl = 'https://openapi.cappt.cc';

const CapptTools = {
    GenerateOutline: 'generate_outline',
    GeneratePresentation: 'generate_presentation'
};

const GenerateOutlinePromptTemplate = `## 角色
你是一名PPT大纲生成专家，擅长根据主题生成逻辑清晰、内容丰富的PPT提纲。
## 任务
根据用户输入的主题信息，生成符合以下规则的PPT大纲，语言需与主题一致，仅输出符合格式要求的大纲内容。
## 规则
1. 语言一致：大纲语言必须与输入主题的语言一致。
2. 标题层级：包含1-4级标题：
   - 1级标题：标题及副标题
   - 2级标题：3-5个子主题方向，每个附带一句话副标题
   - 3级标题：每个子主题方向下随机生成3-5个细分领域，每个附带一句话副标题
   - 4级标题：每个细分领域下生成3-8个小章节，附带10-30字的具体内容
3. 数量要求：
   - 每个子主题方向下的细分领域数量不低于3个
   - 每个细分领域下的小章节数量不低于3个
4. 随机性：禁止所有子主题方向和细分领域的标题数量完全相同。
5. 格式：用Markdown格式输出。
## 格式
\`\`\`markdown
# [标题]
> [副标题]
## 1. [子主题方向]
> [子主题方向的副标题]
### 1.1 [细分领域]
> [细分领域的副标题]
#### 1.1.1 [小章节]
> [小章节具体内容]
\`\`\`
## 输出格式
\`\`\`
# 主题
> 副标题
## 1. 子主题方向
> 子主题方向的副标题
### 1.1 细分领域
> 细分领域的副标题
#### 1.1.1 小章节
> 小章节具体内容
\`\`\`

## 用户输入如下：
'''
{input}
'''

## 约束
生成标准大纲之后，必须调用\`${CapptTools.GeneratePresentation}\`工具生成PPT

## 输出格式
\`\`\`
您的PPT已经生成，共计{totalPage}页，

查看获取源文件请点击链接：
[PPT下载]({editorUrl})

PPT封面预览：
![封面图]({thumbnail})
\`\`\`
`;

class CapptMcpServer {
    private readonly _server: McpServer;
    private readonly _capptUrl: string;
    private readonly _capptToken: string;

    constructor(capptUrl: string, capptToken: string) {
        this._server = new McpServer(
            {
                name: 'Cappt',
                version: '0.0.1',
            },
            {
                instructions: `Use \`${CapptTools.GenerateOutline}\` to generate a standard outline, then use \`${CapptTools.GeneratePresentation}\` to create the presentation`,
                capabilities: {
                    tools: {},
                    logging: {},
                }
            }
        );
        this._capptUrl = capptUrl;
        this._capptToken = capptToken;
        this._setupServer();
    }

    _setupServer() {
        this._server.prompt(
            CapptTools.GenerateOutline,
            'Generate a standard outline based on user input.',
            {
                input: z.string().describe('User input, eg: title, article, etc.')
            },
            ({input}) => ({
                messages: [{
                    role: 'user',
                    content: {
                        type: 'text',
                        text: GenerateOutlinePromptTemplate.replace('{input}', input)
                    }
                }]
            })
        );

        this._server.tool(
            CapptTools.GeneratePresentation,
            `Generate presentation based on the outline generated by \`${CapptTools.GenerateOutline}\``,
            {
                outline: z.string().describe(`A standard outline generated by \`${CapptTools.GenerateOutline}\``),
                include_gallery: z.boolean().optional().describe('Include gallery in the generation result')
            },
            async ({outline, include_gallery}) => {
                const response = await fetch(`${this._capptUrl}/ppt`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${this._capptToken}`,
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({'outline': outline, 'includeGallery': include_gallery}),
                });
                const result = await response.json();
                const data = GeneratePresentationResponse.parse(result);
                const code = data.code;
                const body = data.data;
                const text = code != 200
                    ? `Failed to generate presentation: ${JSON.stringify(data)}`
                    : JSON.stringify(body);
                return {
                    content: [{type: 'text', text: text}]
                };
            }
        )
    }

    async connect(transport: Transport) {
        await this._server.connect(transport);
    }
}

type CapptOptions = {
    capptUrl: string;
    capptToken?: string | undefined;
    transport: 'stdio' | 'http';
    httpHost: string;
    httpPort: number;
};

function getToken(options: CapptOptions, req: Request): string | undefined {
    return req.query.token as string | undefined || req.headers['authorization']?.replace('Bearer ', '') || options.capptToken;
}

async function runStdioServerTransport(options: CapptOptions) {
    const transport = new StdioServerTransport();
    if (!options.capptToken) {
        throw new Error('CAPPT_TOKEN is required when using stdio transport');
    }
    const server = new CapptMcpServer(options.capptUrl, options.capptToken);
    await server.connect(transport);
}

async function runHttpServerTransport(options: CapptOptions) {
    const app = express();
    const transports = {
        streamable: {} as Record<string, StreamableHTTPServerTransport>,
        sse: {} as Record<string, SSEServerTransport>
    };
    // Modern Streamable HTTP endpoint
    app.all('/mcp', async (req: Request, res: Response) => {
        const token = getToken(options, req);
        if (!token) {
            const error: JSONRPCError = {
                jsonrpc: '2.0',
                id: '',
                error: {
                    code: ErrorCode.InvalidParams,
                    message: 'Token is required for authentication',
                }
            }
            res.status(403).json(error);
            return;
        }
        const sessionId = req.headers['mcp-session-id'] as string | undefined;
        let transport: StreamableHTTPServerTransport;
        switch (req.method) {
            case 'POST':
                if (sessionId && transports.streamable[sessionId]) {
                    transport = transports.streamable[sessionId];
                } else if (!sessionId && isInitializeRequest(req.body)) {
                    transport = new StreamableHTTPServerTransport({
                        sessionIdGenerator: () => randomUUID(),
                        onsessioninitialized: (sessionId) => {
                            transports.streamable[sessionId] = transport;
                        }
                    });
                    transport.onclose = () => {
                        if (transport.sessionId) {
                            delete transports.streamable[transport.sessionId];
                        }
                    };
                    const server = new CapptMcpServer(options.capptUrl, token);
                    await server.connect(transport);
                } else {
                    const error: JSONRPCError = {
                        jsonrpc: '2.0',
                        id: '',
                        error: {
                            code: ErrorCode.InvalidParams,
                            message: 'No valid session ID provided',
                        },
                    }
                    res.status(400).json(error);
                    return;
                }

                await transport.handleRequest(req, res, req.body);
                break;
            case 'GET':
            case 'DELETE':
                if (!sessionId || !transports.streamable[sessionId]) {
                    res.status(400).send('Invalid or missing session ID');
                    return;
                }

                transport = transports.streamable[sessionId];
                await transport.handleRequest(req, res);
                break;
        }
    });
    // Legacy SSE endpoint for older clients
    app.get('/sse', async (req: Request, res: Response) => {
        const transport = new SSEServerTransport('/messages', res);
        transports.sse[transport.sessionId] = transport;
        res.on('close', () => {
            delete transports.sse[transport.sessionId];
        });
        const token = getToken(options, req);
        if (!token) {
            res.status(403).send('Unauthorized: No valid token provided');
            return;
        }
        const server = new CapptMcpServer(options.capptUrl, token);
        await server.connect(transport);
    });
    app.post('/messages', async (req: Request, res: Response) => {
        const sessionId = req.query.sessionId as string;
        const transport = transports.sse[sessionId];
        if (transport) {
            await transport.handlePostMessage(req, res);
        } else {
            res.status(400).send('No transport found for sessionId');
        }
    });
    app.listen(options.httpPort, options.httpHost);
}

async function main() {
    const program = new Command();
    program.addOption(new Option('--cappt-url <url>', 'Cappt API base URL').env('CAPPT_URL').default(CapptBaseUrl))
        .addOption(new Option('--cappt-token <token>', 'Cappt API token').env('CAPPT_TOKEN'))
        .addOption(new Option('--transport <method>', 'Transport method').choices(['stdio', 'http']).env('TRANSPORT').default('stdio'))
        .addOption(new Option('--http-host <host>', 'HTTP server host').env('HTTP_HOST').default('0.0.0.0'))
        .addOption(new Option('--http-port <port>', 'HTTP server port').env('HTTP_PORT').default(8000));
    program.parse(process.argv);
    const options = program.opts() as CapptOptions;
    if (options.transport === 'stdio') {
        await runStdioServerTransport(options);
    } else if (options.transport === 'http') {
        await runHttpServerTransport(options);
    } else {
        throw new Error(`Unsupported transport method: ${options.transport}`);
    }
}

main().catch((error) => {
    console.error('Fatal error in main():', error);
    process.exit(1);
});
